```
func pizzeria(pizzaMaker *Producer) {

var i = 0

//keep track of which pizza we're making

  

//run forever until we recieve a quit notification

  

//try to make pizzas

  

for {

currentPizza := makePizza(i)

//try to make a pizza

  

if currentPizza != nil {

i = currentPizza.pizzaNumber

select {

//we tried to make a pizza -> we sent something to the data channel

case pizzaMaker.data <- *currentPizza:

  

case quitChan := <-pizzaMaker.quit:

//close the channel

close(pizzaMaker.data)

close(quitChan)

return

}

  

//decision

}

}

}
```

This is the consumer.

Now running the consumer.

```
for i := range pizzaJob.data {

if i.pizzaNumber <= NumberOfPizzas {

if i.success {

color.Green(i.message)

color.Green("Order #%d is out for delivery", i.pizzaNumber)

} else {

color.Red(i.message)

color.Red("The customer of order #%d is really angry", i.pizzaNumber)

}

} else {

color.Cyan("Done making pizzas")

err := pizzaJob.Close()

if err != nil {

color.Red("*** Error closing channel", err)

}

}

}
```

So, what I've learnt 
1.  Understanding `for range` on a Channel

1. **Waiting for Values**:
    
    - The `for i := range pizzaJob.data` loop continuously waits for new `PizzaOrder` instances to be sent on the `pizzaJob.data` channel.
    - Each time a `PizzaOrder` is sent through the channel, the loop iterates, and the variable `i` holds the current value sent through the channel.
2. **Processing Values**:
    
    - Inside the loop, you can process each received `PizzaOrder`. Depending on the properties of the order (like `success` and `pizzaNumber`), you print different messages using the `color` package.


Now, let's assume that the makePizza function collapses. What will happen is we will get stuck in a deadlock situation.

Final Code.

```
package main

  

import (

"fmt"

"math/rand"

"time"

  

"github.com/fatih/color"

)

  

const NumberOfPizzas = 10

  

var pizzasMade, pizzasFail, total int

  

type Producer struct {

data chan PizzaOrder

quit chan chan error

}

  

// Close is simply a method to close a channel when we are done with it.

// It means we push something to the quit channel.

func (p *Producer) Close() error {

ch := make(chan error)

p.quit <- ch

return <-ch

}

  

type PizzaOrder struct {

pizzaNumber int

message string

success bool

}

  

/*

makePizza is a function that recieves a pizzaNumber

and based upon that pizzaNumber.

  

1. If pizzaNumber <= NumberofPizzas

it means making pizza is feasible and we take a random delay to how much

time will the pizza tale.

Now based upon chance, the pizza will fail.

  

2. If pizza making fails for different reasons, like ran out of items, the cook is OOO.

  

3. Else no issues the pizza making is success...

  

We now need to return either with all the data available or with no data.

*/

func makePizza(pizzaNumber int) *PizzaOrder {

pizzaNumber++

  

if pizzaNumber <= NumberOfPizzas {

delay := rand.Intn(5) + 1

fmt.Printf("Recieved order #%d!\n", pizzaNumber)

  

rnd := rand.Intn(12) + 1

msg := ""

success := false

  

if rnd < 5 {

pizzasFail++

} else {

pizzasMade++

}

total++

  

fmt.Printf("Making pizza #%d, it will take %d seconds\n", pizzaNumber, delay)

time.Sleep(time.Duration(delay) * time.Second)

  

if rnd <= 2 {

msg = fmt.Sprintf("*** We ran out of ingredients for pizza #%d", pizzaNumber)

} else if rnd <= 4 {

msg = fmt.Sprintf("The cook took an early day leave for pizza #%d", pizzaNumber)

} else {

success = true

msg = fmt.Sprintf("The pizza order #%d is ready", pizzaNumber)

}

  

p := PizzaOrder{

pizzaNumber: pizzaNumber,

message: msg,

success: success,

}

  

return &p

  

}

  

return &PizzaOrder{

pizzaNumber: pizzaNumber,

}

}

  

/*

Pizzeria is a goroutine that runs in the bg and calls makePizza to try to make

one order each time it iterates through the indefinite for-loop.

We order one pizza to makePizza.

It executes until we recieve something on the quit channel.

The quit channel doesn't recieve anything until the consumer sends it

(when the number of orders >= const NumberOfPizzas).

*/

func pizzeria(pizzaMaker *Producer) {

var i = 0

//keep track of which pizza we're making

  

//run forever until we recieve a quit notification

  

//try to make pizzas

  

for {

currentPizza := makePizza(i)

//try to make a pizza

  

if currentPizza != nil {

i = currentPizza.pizzaNumber

select {

//we tried to make a pizza -> we sent something to the data channel

case pizzaMaker.data <- *currentPizza:

  

case quitChan := <-pizzaMaker.quit:

//close the channel

close(pizzaMaker.data)

close(quitChan)

return

}

  

//decision

}

}

}

  

func main() {

//Seed the random number generator

rand.Seed(time.Now().UnixNano())

//rand.Seed via now is generated by default

  

//print out a message that program has started

color.Cyan("The Pizzeria is open for business")

color.Cyan("---------------------------------")

  

//create a producer

pizzaJob := &Producer{

data: make(chan PizzaOrder),

quit: make(chan chan error),

}

  

//run the producer in the background

  

go pizzeria(pizzaJob)

  

//create and run consumer

  

for i := range pizzaJob.data {

if i.pizzaNumber <= NumberOfPizzas {

if i.success {

color.Green(i.message)

color.Green("Order #%d is out for delivery", i.pizzaNumber)

} else {

color.Red(i.message)

color.Red("The customer of order #%d is really angry", i.pizzaNumber)

}

} else {

color.Cyan("Done making pizzas")

err := pizzaJob.Close()

if err != nil {

color.Red("*** Error closing channel", err)

}

}

}

  

//Will print out the ending message

color.Cyan("----------------------")

color.Cyan("Done for the day")

  

color.Cyan("We made %d pizzas, failed to make %d pizzas, with %d total orders recieved,", pizzasMade, pizzasFail, total)

  

switch {

case pizzasFail > 9:

color.Red("It was an awful day")

case pizzasFail >= 6:

color.Red("It was not a very good day")

case pizzasFail >= 4:

color.Yellow("It was an OK day")

case pizzasFail >= 2:

color.Yellow("It was a pretty good day")

default:

color.Green("It was a great day")

}

}
```